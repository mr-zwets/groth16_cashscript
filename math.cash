library Math {
  // Helper function to compute x^y % p (modular exponentiation)
  // Work around not having shift to check if the ith bit of exp is set
  // if ((exp & (1 << i)) != 0) -> if (expCopy % 2 != 0)
  function powMod(int base, int exp, int mod) returns (int) {
    int result = 1;           // Initialize result to 1
    int current = base % mod;  // Start with base mod p
    int expCopy = exp;         // Copy exp to modify it in the loop

    // Process each bit of `expCopy` by repeatedly dividing by 2
    for (int i = 0; i < 256; i++) {  // Assuming a 256-bit exponent for BN256
      if (expCopy % 2 != 0) {        // Check if the least significant bit is set
        result = (result * current) % mod;
      }
      current = (current * current) % mod; // Square current for the next bit
      expCopy = expCopy / 2;         // Move to the next bit by dividing expCopy by 2
    }

    return result % mod;  // Return the final modular exponentiation result
  }
}
